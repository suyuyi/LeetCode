[1177. Can Make Palindrome from Substring](https://leetcode-cn.com/problems/can-make-palindrome-from-substring/)  
字符串的长度为\[1,10^5\],查询请求的个数为\[1,10^5\]  
如果对每个请求截取subString然后处理，即便时O(n)复杂度也会超时  
因为本题可以重新排序和替换，对于一个字符串：
* 先重排，通过重排可以只留下一堆不重复的字母，如\{a,a,a,b\}可以变为\{a,a,b,a\}  
* 然后考虑替换，首先重排过滤掉的字母一定是偶数个，因此字符串长度为奇数则剩余字母也是奇数个，偶数同理，而奇数个可以沿中心元素对称，即中心元素不需要重复，因此最少替换个数都为floor\(剩余个数/2\)
* 判断最少替换个数和k的大小得出结果

因此只需知道subString中各个字母的个数即可，这样可以采取前缀和的解法，prefixSum\[i\]\[j\]表示s.substring(0,i+1)的第j个字母（{a,b,c,d,...}）的个数,通过初始化前缀和，任意一个子字符串都可以在常数时间内求出字母的数量，总的时间复杂度为O(n)  
进一步分析，具体字母的个数也没必要知道，只需要知道字母出现个数的奇偶性即可，可以用位运算来表示每一个字母出现的奇偶性，即prefixSum\[i\]的第一位为a出现次数的奇偶性  
同时 奇数-奇数=偶数、偶数-偶数=偶数、奇数-偶数=奇数、偶数-奇数=奇数，恰好可以用异或处理，即prefixSum[i-1]^prefixSum[j]就表示字符串\[i,j\]间的字母出现的数量的奇偶性，统计其中1的个数，然后处理手法与上面一致  
最后可以再加一个小优化，用5次操作统计1的个数
```java
class Solution {
    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {
        // init
        int[] prefixSum = new int[s.length()];
        prefixSum[0]^=(1<<(s.charAt(0)-'a'));
        for(int i=1;i<s.length();++i) {
            prefixSum[i] = prefixSum[i-1];
            prefixSum[i]^=(1<<(s.charAt(i) - 'a'));
        }
        List<Boolean> res = new ArrayList<>();
        for(int[] query:queries){
            int cnt=0;
            int start=query[0],end=query[1],k=query[2];
            // 奇数-奇数=偶数；偶数-偶数=偶数
            // 奇数-偶数=奇数；偶数-奇数=奇数
            if(start==0){
                for(int i=0;i<26;++i)
                    cnt=prefixSum[end];
            }
            else{
                for(int i=0;i<26;++i)
                    cnt=prefixSum[start-1]^prefixSum[end];
            }
            res.add((Math.floorDiv(count(cnt),2)<=k)?Boolean.TRUE:Boolean.FALSE);
        }
        return res;
    }

    private int count(int n){
        n = (n & 0x55555555) + ((n >>> 1)  & 0x55555555);
        n = (n & 0x33333333) + ((n >>> 2)  & 0x33333333);
        n = (n & 0x0f0f0f0f) + ((n >>> 4)  & 0x0f0f0f0f);
        n = (n & 0x00ff00ff) + ((n >>> 8)  & 0x00ff00ff);
        n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);
        return n;
    }
}
```

[417. Pacific Atlantic Water Flow](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)  
双源BFS，看起来很难，但想清楚后很简单，过往的BFS都是从单源出发，从未知向已知探索，但这个可以反其道而行之，从已知的地方出发，遍历全图，汇总后得出结果  
```java
static int[] a={0,1,0,-1},b={1,0,-1,0};
static int[][] heights;
public List<List<Integer>> pacificAtlantic(int[][] _heights) {
    int m=_heights.length,n=_heights[0].length;
    heights=_heights;
    boolean[][] sea1 = new boolean[m][n], sea2 = new boolean[m][n];
    Queue<int[]> queue1 = new LinkedList<>(),queue2 = new LinkedList<>();
    for(int i=0;i<m;++i)
        for(int j=0;j<n;++j){
            if(j==0||i==0) {
                sea1[i][j] = true;
                queue1.add(new int[]{i,j});
            }
            if(i==m-1||j==n-1) {
                sea2[i][j] = true;
                queue2.add(new int[]{i,j});
            }
        }
    bfs(queue1,sea1);bfs(queue2,sea2);
    List<List<Integer>> ans = new ArrayList<>();
    for(int i=0;i<m;++i)
        for(int j=0;j<n;++j)
            if(sea1[i][j]&&sea2[i][j]) ans.add(Arrays.asList(i,j));
    return ans;
}
void bfs(Queue<int[]> queue,boolean[][] sea){
    while (!queue.isEmpty()){
        int[] pos = queue.poll();
        for(int i=0;i<4;++i){
            int tm = pos[0]+a[i],tn = pos[1]+b[i];
            int m=sea.length,n=sea[0].length;
            if(tm<0||tm>=m||tn<0||tn>=n) continue;
            if(sea[tm][tn]||heights[tm][tn]<heights[pos[0]][pos[1]]) continue;
            sea[tm][tn]=true;
            queue.add(new int[]{tm,tn});
        }
    }
}
```

[48. Rotate Image](https://leetcode-cn.com/problems/rotate-image/)  
由于不能使用额外空间，因此只能原地旋转，大致思路是将二维数组的坐标转化为一个坐标系，原点为中心点（奇数长度存在，偶数长度不存在）  
然后将其按照正常方式旋转，之后再转换回去，其中较为困难的地方是坐标系的转换，数组是\[row\]\[col\]而坐标系是\[col\]\[row\]，我这边采用的是\[row\]\[col\]的方式，因此旋转时要注意
```java
class Solution {
    static Integer len;
    public void rotate(int[][] matrix) {
        len = matrix.length;
        if(len==1) return;
        if(len%2==0){
            for(int i=0;i<len/2;++i)
                for(int j=0;j<len/2;++j){
                    int[] pos = new int[] {i,j};
                    int tmp = matrix[pos[0]][pos[1]];
                    for(int cnt=0;cnt<4;++cnt){
                        // 先转换为坐标系，逆时针旋转，再转换回数组
                        int[] prev = transferFromCoordinate(counterClockWise(transferToCoordinate(pos)));
                        if(cnt==3) matrix[pos[0]][pos[1]]=tmp;
                        else matrix[pos[0]][pos[1]] = matrix[prev[0]][prev[1]];
                        pos[0]=prev[0];pos[1]=prev[1];
                    }
                }
        }
        else{
            for(int i=0;i<len/2;++i)
                for(int j=0;j<=len/2;++j){
                    int[] pos = new int[] {i,j};
                    int tmp = matrix[pos[0]][pos[1]];
                    for(int cnt=0;cnt<4;++cnt){
                        int[] prev = transferFromCoordinate(counterClockWise(transferToCoordinate(pos)));
                        if(cnt==3) matrix[pos[0]][pos[1]]=tmp;
                        else matrix[pos[0]][pos[1]] = matrix[prev[0]][prev[1]];
                        pos[0]=prev[0];pos[1]=prev[1];
                    }
                }
        }
    }
    // 由于转换后得到的结果是[row][col]，即纵坐标在前横坐标在后，所以转换需要注意
    private int[] counterClockWise(int[] pos){
        int[] res = new int[2];
        res[1] = -pos[0];
        res[0]= pos[1];
        return res;
    }
    private int[] transferToCoordinate(int[] pos){
        int center = Math.floorDiv(len,2);
        int[] res = new int[2];
        if(len%2==1){
            res[0]=center-pos[0];
            res[1]=pos[1]-center;
        }
        else{
            res[0]=(pos[0]>=center)?center-pos[0]-1 :center-pos[0];
            res[1]=(pos[1]>=center)?pos[1]-center+1 :pos[1]-center;
        }
        return res;
    }
    private int[] transferFromCoordinate(int[] pos){
        int center = Math.floorDiv(len,2);
        int[] res = new int[2];
        if(len%2==1){
            res[0]=center-pos[0];
            res[1]=pos[1]+center;
        }
        else{
            res[0]=(pos[0]<=0)?center-pos[0]-1:center-pos[0];
            res[1]=(pos[1]>=0)?center-1+pos[1]:center+pos[1];
        }
        return res;
    }
}
```

[47. Permutations II](https://leetcode-cn.com/problems/permutations-ii/)  
本题的关键在于排除重复解，重复解的特点是都存在一个连续相等的序列，可以通过限制连续相等的序列出现的数量来排除重复解  
大致思路是递归时如果上一层已经选中了某个元素，则由上一层负责有关该元素的连续序列的生成，本层不再选择相同的元素，以免重复。  
如[1,1,1,5]，假设第一层选择了1，则由第一层生成1,11,111这三个序列，第二层直接跳过1，以免出现 第一层1，第二层11 + 第一层11，第二层1 这种重复出现的情况，
大致思路：
* 统计序列中元素个数
* dfs+回溯，同时跳过上一个元素
```Java
class Solution {
    static Map<Integer,Integer> unUsed = new HashMap<>();
    static List<List<Integer>> res = new ArrayList<>();
    static List<Integer> ans = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        unUsed.clear();res.clear();ans.clear();
        for(int i:nums){
            Integer cnt = unUsed.getOrDefault(i,0);
            unUsed.put(i,cnt+1);
        }
        dfs(0,nums,-20);
        return res;
    }
    public void dfs(int pos,int[] nums,int prev){
        if(pos== nums.length){
            List<Integer> tmp = new ArrayList<>();
            for(int i:ans) tmp.add(i);
            res.add(tmp);
            return;
        }
        for(int i:unUsed.keySet()){
            // 跳过上一个元素
            if(i!=prev&&unUsed.get(i)>0){
                int cnt = unUsed.get(i);
                for(int j=1;j<=cnt;++j){
                    for(int k=0;k<j;++k) ans.add(i);
                    unUsed.put(i,cnt-j);
                    dfs(pos+j,nums,i);
                    for(int k=0;k<j;++k) ans.remove(ans.size()-1);
                    unUsed.put(i,cnt);
                }
            }
        }
    }
}
```

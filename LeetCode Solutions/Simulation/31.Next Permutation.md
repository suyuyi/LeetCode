[31. Next Permutation](https://leetcode-cn.com/problems/next-permutation/)  
本题的难点在于如何**从一个给定数字序列生成下一个字典序的序列**  
思路为:  
1. 从后向前，找到第一个严格升序对(i,j)，符合 i<j and nums[i]>nums[j]
2. 找到[j,end]里大于nums[i]且与其最接近的k
3. 置换i,k的值，并将[j,end]升序排列即可得到下一个字典序序列 
```java
public void nextPermutation(int[] nums) {
    if(nums.length==1) return;
    int end,seqEnd;
    end=0;
    seqEnd=-1;
    while((end+1)<nums.length){
        if(nums[end+1]>nums[end]) seqEnd=end+1;
        end++;
    }
    if(seqEnd==-1)
        Arrays.sort(nums);
    else{
        int target = nums[seqEnd-1],maxPos=seqEnd;
        // 可以从后向前找，第一个大于的就是，因为后面是降序序列
        for(int i=seqEnd;i<nums.length;++i){
            if(nums[i]>target&&nums[i]<=nums[maxPos]) maxPos=i;
        }
        nums[seqEnd-1]=nums[maxPos];
        nums[maxPos]=target;
        // 置换后[j,end]仍为降序序列，直接反转即可
        quickSort(nums,seqEnd, nums.length-1);
    }
}
private void quickSort(int[] nums,int left,int right){
    if(left>=right) return;
    int key = nums[left];
    int leftIndex = left,rightIndex =right;
    while(leftIndex<rightIndex){
        while(rightIndex>leftIndex&&nums[rightIndex]>=key) rightIndex--;
        nums[leftIndex]=nums[rightIndex];
        while(leftIndex<rightIndex&&nums[leftIndex]<=key) leftIndex++;
        nums[rightIndex]=nums[leftIndex];
    }
    nums[leftIndex] =key;
    quickSort(nums,left,leftIndex-1);
    quickSort(nums,rightIndex+1,right);
}
```

[6044.Number of Flowers in Full Bloom](https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/)  
乍看感觉是树状数组之类的范围修改、查询，但实际思路比较多
1. 将flower拆为开始和结束两个节点，然后再将游客也作为节点，根据日期做HashMap，统计个数
2. 排序，随后从第一天开始，每天先加上开始节点的数值，统计当日总数值，如果当日有游客，记录，随后减去结束节点的数值
3. 处理游客记录
```java
public int[] fullBloomFlowers(int[][] flowers, int[] persons) {
    // 1 - start,2 - end,4 - person
    Map<Integer,Integer[]> map = new HashMap<>();
    for(int[] flower:flowers){
        int start = flower[0],end=flower[1];
        // arr[0] - start, arr[1] - end, arr[2] - person
        Integer[] startArr = map.getOrDefault(start,new Integer[] {0,0,0});
        startArr[0]+=1;
        map.put(start,startArr);
        Integer[] endArr = map.getOrDefault(end,new Integer[] {0,0,0});
        endArr[1]+=1;
        map.put(end,endArr);
    }
    for(int person:persons){
        Integer[] personArr = map.getOrDefault(person,new Integer[] {0,0,0});
        personArr[2]+=1;
        map.put(person,personArr);
    }
    Integer[] days = map.keySet().toArray(new Integer[0]);
    Arrays.sort(days);
    int cntFlower=0;
    Map<Integer,Integer> res = new HashMap<>();
    for(Integer day:days){
        Integer[] dayStat = map.get(day);
        cntFlower+=dayStat[0];
        if(dayStat[2]>0) res.put(day,cntFlower);
        cntFlower-=dayStat[1];
    }
    int[] ans = new int[persons.length];
    int idx=0;
    for(int person:persons)
        ans[idx++]=res.get(person);
    return ans;
}
```

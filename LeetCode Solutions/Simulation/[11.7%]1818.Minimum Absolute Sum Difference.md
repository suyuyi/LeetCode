[1818. Minimum Absolute Sum Difference](https://leetcode-cn.com/problems/minimum-absolute-sum-difference/)  
记录本题的原因一个是没做出来，另外是耗时太长有待优化  
本题的解法是二分查找，对每个nums2查找距离最近的nums1，比较与原本的nums1的差值，如果能减小就记录，直到遍历完找到最大的减小的值  
```java
class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        int p = 1000000007;
        int[] sorted = new int[nums1.length];
        for(int i=0;i<nums1.length;++i) sorted[i] =nums1[i];
        Arrays.sort(sorted);
        int minus=0,pos=-1;
        for(int i=0;i<nums2.length;++i){
            int origin = Math.abs(nums1[i]-nums2[i]);
            int searchRes = binarySearch(sorted,0, nums1.length-1,nums2[i]);
            if(minus<(origin-Math.abs(sorted[searchRes]-nums2[i]))){
                minus = origin-Math.abs(sorted[searchRes]-nums2[i]);
            }
        }
        minus = -minus;
        for(int i=0;i<nums1.length;++i){
            minus+=Math.abs(nums1[i]-nums2[i]);
            minus%=p;
        }
        return minus;
    }
    private int binarySearch(int[] sorted,int start,int end,int target){
        if((end-start)==1) return (Math.abs(sorted[end]-target)<=Math.abs(sorted[start]-target))?end:start;
        else if(end==start) return end;
        // 分割点判断
        int mid = Math.floorDiv(start+end,2);
        if(target==sorted[mid]) return mid;
        int pos = mid;
        if(target<sorted[mid]) pos = binarySearch(sorted,start,mid-1,target);
        else pos = binarySearch(sorted,mid+1,end,target);
        return (Math.abs(sorted[pos]-target)<=Math.abs(sorted[mid]-target))?pos:mid;
    }
}
```

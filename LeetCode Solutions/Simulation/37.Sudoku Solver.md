[37. Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver/)  
解法基本一下就能看出来:dfs+回溯+剪枝,代码如下:  
```java
static int[] vertical = {0,0,0,1,1,1,-1,-1,-1},horizon = {0,-1,1,0,-1,1,0,-1,1};
static int[] target = {1,4,7};
static boolean findIt = false;
static List<int[]> emptyPos = new ArrayList<>();
public void solveSudoku(char[][] board) {
    emptyPos.clear();
    findIt=false;
    // 获取所有空的位置
    for(int i=0;i<9;++i)
        for(int j=0;j<9;++j){
            if(board[i][j]!='.') continue;
            int[] pos = new int[2];
            pos[0]=i;pos[1]=j;
            emptyPos.add(pos);
        }
    // 开始dfs
    findAns(board,0);
}

private void findAns(char[][] board,int cnt){
    // 走到尽头说明已经有了一个答案，而题目中明确解法唯一
    // 因此改变标记位，将后续dfs剪除
    if(cnt==emptyPos.size()){
        findIt=true;
        return;
    }
    if(findIt) return;
    int[] pos = emptyPos.get(cnt);
    int[] center = getCenter(pos[0],pos[1]);
    int[] possible = new int[9];
    Arrays.fill(possible,0);
    // 挑选合法的可选值，即possible中值为0的位置
    for(int i=0;i<9;++i){
        if(board[pos[0]][i]!='.') possible[board[pos[0]][i]-'1']++;
        if(board[i][pos[1]]!='.') possible[board[i][pos[1]]-'1']++;
        if(board[center[0]+horizon[i]][center[1]+vertical[i]]!='.') possible[board[center[0]+horizon[i]][center[1]+vertical[i]]-'1']++;
    }
    for(int i=0;i<9;++i){
        if(possible[i]==0&&!findIt){
            board[pos[0]][pos[1]]=String.valueOf(i+1).charAt(0);
            findAns(board,cnt+1);
            if(!findIt) board[pos[0]][pos[1]]='.';
        }
    }
}
// 获取pos所在的3*3区块的中心点
private int[] getCenter(int x,int y){
    int[] res = new int[2];
    for(int i:target)
        for(int j:target){
            if(Math.abs(x-i)<=1&&Math.abs(y-j)<=1) {
                res[0]=i;res[1]=j;
                return res;
            }
        }
    return res;
}
```

[780.Reaching Points](https://leetcode-cn.com/problems/reaching-points/)  
首先本题必须反推，正推(BFS)根本不可能，对于反推(tx,ty)，可知如果tx=ty，则  
* 没有转换 -> 题目规定必须转换
* 必然从(0,ty) or (tx,0)转换而来 -> 题目规定x>0,y>0

因此tx必不等于ty，则必然存在大小关系，(tx-ty,ty),(tx,ty-tx)二者中只有一个符合 x>0,y>0 的规定，这为反推提供了线性的解法  
但是由于x,y<=10^9，即便是O(n)的解法仍然有可能超时,可以**辗转相除**的方式，尝试先让其中一个元素到达原点值，有两种可能的结果:
* 元素小于原初值 -> 必然不存在(不会错过中间的值，因为这就是对辗转相减的模拟)
* 元素等于初始值 -> 判断另一个元素与对应原初元素之间的差值能否被该元素整除  

感谢[大佬的启发](https://leetcode-cn.com/problems/reaching-points/solution/by-ac_oier-hw11/)
```java
public boolean reachingPoints(int sx, int sy, int tx, int ty) {
    while(sx<tx&&sy<ty){
        if(tx>ty) tx %=ty;
        else ty%=tx;
    }
    if(sx>tx||sy>ty) return false;
    if(sx==tx) return ((ty-sy)%tx)==0;
    else return ((tx-sx)%ty)==0;
}
```
